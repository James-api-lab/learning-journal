
---

## üìò Learning Journal ‚Äî Week 4, Day 1

BACK IN PYTHON BABY! It is crazy how much more comfortable I feel with it. 

**Theme:** Flask API Foundations ‚Äî from CLI scripts to running a local microservice.

---

### üéØ Goal
Transition from standalone Python CLI scripts to a **web-accessible Flask API** that returns structured JSON responses and supports modular endpoints.

---

### üß© What I Built
- **Flask API App (`app.py`)**  
  - Core routes: `/`, `/health`, `/meta`, `/demo`  
  - Structured logging via `RotatingFileHandler`  
  - Environment configuration with `.env`  
  - JSON-only error responses (404 + 500 handlers)  
  - Dynamic metadata (`app.config["VERSION"]`)

- **Testing endpoints:**  
  - Used PowerShell‚Äôs `iwr` and `curl.exe` to verify routes.  
  - Confirmed proper 200, 404, and 500 JSON payloads.

---

### üí° Key Concepts Learned
- Flask route decorators and HTTP methods (`@app.route()`)
- Handling configuration cleanly with `.env` + `dotenv`
- Safe error handling ‚Äî returning consistent JSON on crashes
- Rotating logs for persistent, production-like monitoring
- GitHub push protection (and how to safely remove secrets!)
- Managing environment files securely (`.gitignore`, `.env.example`)
- Structuring a project for future FastAPI or microservice conversion

---

### üß† Reflections
This day felt like crossing a bridge from **scripts** ‚Üí **services**.  
Seeing the JSON responses in the browser or terminal made the logic tangible. I also hit my first real-world problem ‚Äî GitHub push protection due to committed secrets ‚Äî and learned how to rewrite Git history safely using `git filter-repo`.

---

### ‚úÖ Next Steps (W4D2 Preview)
- Add `/weather` route powered by OpenWeather API (using the key in `.env`)
- Return live JSON with city, temperature, and condition
- Test with multiple city parameters (`?city=Seattle`)
- Log API calls and response times in `/data/access.log`


# Week 4 Day 1, again ‚Äî Flask Foundations Journal

### Date

October 5, 2025

### Theme

Flask Foundations: Building and Serving Your First API

### Summary

Today marked a reset and a fresh start for my API learning journey ‚Äî literally. I had to delete my original Week 4 folder and start over after a messy GitHub setup with push protection issues and environment variable leaks. I committed all of my APIs - fun times. While frustrating, it was also an important learning moment about version control hygiene, environment safety, and patience.

I partially rebuilt my **Week 4 - Flask API** project from scratch, reconnected GitHub cleanly under my **James-api-lab** organization, and successfully pushed my foundational files ‚Äî `app.py`, `config.py`, and `README.md`. This time, I followed a step-by-step, no-rush approach that ensured each step worked before moving on.

### What I Accomplished

* ‚úÖ Created a clean new project folder under `Learning APIs/Week 4 - Flask API`.
* ‚úÖ Initialized a new Git repo and added `.gitignore` and `.env.example` safely.
* ‚úÖ Authenticated via GitHub CLI and pushed the repo to my organization.
* ‚úÖ Copied in and committed key files: `app.py`, `config.py`, `README.md`.
* ‚úÖ Verified Flask runs locally and returns `{"message": "Week 4 Flask API is live"}`.

### Lessons Learned

* Secrets and `.env` files should **never** be tracked in Git. Even one mistake can block pushes.
* Starting clean sometimes saves more time than debugging a broken setup.
* GitHub CLI (`gh`) is much more reliable than manual HTTPS setup once properly authenticated.
* I understand how to structure and protect a Flask project more confidently now.

### Next Steps

Tomorrow, I‚Äôll move into **Day 2**, learning how to use **path parameters** and **query parameters** in Flask routes. I‚Äôll make sure the explanations include both what to do *and why* ‚Äî to reinforce conceptual understanding.

### Reflection

Today‚Äôs reset felt like a small failure but turned into one of my best real-world learning experiences yet. Version control, security, and good project hygiene are as much a part of being a developer as writing the code itself. I‚Äôm ending the day with a clean project, clear mind, and a running Flask API.

----


# Week 4 ‚Äî Days 1‚Äì2 Journal

**Dates:** Oct 5, 2025 (restart); continues into Day 2  
**Theme:** Flask foundations ‚Üí path/query/body inputs

---

## What happened (honest version)

I borked my first attempt: leaked `.env` once, which tripped GitHub push protection.  
Tried to clean history; it got messier. I deleted the repo/folder and restarted clean.  
This time I created a clean project, added `.gitignore` and `.env.example` first, and used `gh repo create` in my org.

---

## What I built

- Base Flask app with:
  - `/`, `/health`, `/meta`
  - JSON 404 + 500 handlers
  - Request logging (rotating file + simple access log)
- Day 2 routes:
  - Path params: `/hello/<name>`, `/square/<int:n>`
  - Query params: `/add?a=5&b=9` with validation
  - POST JSON: `POST /echo` echoes body

---

## What I learned (and re-learned)

- **Path vs Query vs Body**:
  - Path = identity (`/users/42`)
  - Query = options/filters (`?limit=10&sort=asc`)
  - Body = actual data for create/update (JSON for POST/PUT)
- **PowerShell quirks**:
  - Use `curl.exe` (not `curl`) and **quote** URLs with `&`.
  - Send JSON with **single quotes** around the payload or use `Invoke-WebRequest`.
- **Errors matter**:
  - 400 for bad input (missing/invalid params)
  - 404 for wrong route
  - 500 for crashes, but return clean JSON
- **Git hygiene**:
  - Don‚Äôt commit `.env`‚Äîever.
  - Starting over can be faster (and cleaner) than wrestling a broken history.

---

## What didn‚Äôt work

- Sending POST JSON from PowerShell was finicky at first (quoting).  
  Fixed by using:  
  `curl.exe -X POST ... -d '{"msg":"hi"}'`  
  or `Invoke-WebRequest` with `-ContentType "application/json"`.

---

## Next

- Day 3: wire `/weather/<city>` to OpenWeather (env key only in local `.env`).
- Day 4: CSV history endpoint.
- Day 5: POST validation and structured errors.

---

## Reflection

I messed up, owned it, and rebuilt it better.  
The restart forced me to understand the workflow deeply: environment safety, GitHub org permissions, and the shape of real APIs.  
I‚Äôm moving forward with a clean project and clearer mental model.

# Week 4 ‚Äî Day 3  
**Project:** Flask API  
**Focus:** Real API Integration + Data Persistence

---

## üå§Ô∏è Overview
After building our foundational Flask routes and JSON responses, today was about **making the API real** ‚Äî connecting to a live data source (OpenWeather), caching results, logging data, and handling real-world errors gracefully.

We started with `/weather/<city>` for a single-city lookup and expanded into `/weather?cities=Seattle,Tokyo,Paris` for bulk fetching, powered by concurrent threads.  

---

## üß© Key Achievements

### 1. Integrated a Live API
- Connected Flask to the **OpenWeather API** using an API key stored in `.env`.
- Added `.env` loading with `Path(__file__).with_name(".env")` for reliable Windows behavior.
- Normalized payloads so every response includes:
  ```json
  {
    "city": "Seattle",
    "units": "metric",
    "temp": 12.4,
    "humidity": 80,
    "description": "light rain",
    "wind_speed": 3.4,
    "ts": "2025-10-06T22:01:00Z",
    "cache": false
  }

2. Implemented Smart Caching

Built a lightweight in-memory cache (_weather_cache) with a 5-minute TTL.
Cache-first lookups prevent unnecessary API calls.
Cached entries are automatically cleaned up after expiration.

3. Logged Everything

Rotating log file (logs/app.log) for detailed runtime logs.
Plain text access log (data/access.log) for quick request audits.
CSV data log (data/weather_log.csv) for weather history persistence.

4. Bulk & Concurrent Fetches

Added /weather?cities=Seattle,New%20York,Paris&units=metric
Parallelized requests with ThreadPoolExecutor while respecting API rate limits.
Combined results + errors into a single clean JSON payload:

{
  "units": "metric",
  "count": 2,
  "results": [ ... ],
  "errors": [ { "city": "NopeCity", "code": 404 } ]
}

5. Graceful Error Handling

Added structured JSON error handlers for:
400 ‚Üí Bad query or missing params
404 ‚Üí Invalid routes
500 ‚Üí Server exceptions
502 ‚Üí Upstream API failure (network or rate limit)
Implemented safe exception logging with app.logger.exception.

üß† Lessons Learned

Load order matters: .env must be loaded before importing Config.
UTC timestamps are crucial for multi-user environments ‚Äî datetime.now(timezone.utc) futureproofs your data.
Concurrent APIs need safeguards: Thread pools with capped worker limits prevent rate-limit bans.
Caching adds realism: Even a simple TTL cache simulates production behavior and improves local performance.
Always log structured data: JSON + CSV logs make debugging and analysis painless later.


## üìò Learning Journal ‚Äî Week 4, Day 3

I finally started connecting the dots with a basic html file in the browser.

I had some trouble again with github, and some issues with the data. I am trying to make the literal and mental connection of query (CLI for now) -> API call -> browser output for user. 

## What I Built
Today‚Äôs focus was making my Flask app feel *alive* ‚Äî pulling live weather data, saving it, and generating charts from my own logs.

I implemented:
- `/weather/<city>` and `/weather?cities=` for live fetches.
- CSV logging (`data/weather_log.csv`) so each API call becomes historical data.
- A lightweight in-memory cache with 5-minute TTL.
- `/history`, `/history/daily`, and `/chart/view` endpoints that visualize past results using QuickChart.

After testing with:
```powershell
iwr "http://127.0.0.1:5000/weather/Seattle"
iwr "http://127.0.0.1:5000/weather/Miami"
```
my charts started showing historical temperatures, humidity, and trends.

---

## Reflections
- I finally felt the jump from ‚Äútoy CLI‚Äù to ‚Äúreal API.‚Äù
- Debugging `.env` paths and cache invalidation taught me how fragile environment setup can be.
- Seeing my own API feed QuickChart URLs felt like a real full-stack moment.
- Git gave me hell again (nested repos), but I learned how to flatten and re-push.

---

## Next Steps
- Clean up chart endpoints (combine `/chart/html` + `/chart/view`)
- Add daily aggregation & rolling averages
- Begin packaging for deploy (Flask app factory pattern)

