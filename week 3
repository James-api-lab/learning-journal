# Week 3 – Day 1
I set up my first Node.js project with pnpm, confirmed I can load my API key from .env, and built scripts to fetch weather data. I started with one city, then looped through multiple, and finished by adding CLI flags with yargs. 
This feels like the JavaScript mirror of what I did in Python last week.

accomplished for W3D1

✅ Installed Node.js & pnpm
✅ Initialized a Node project
✅ Verified .env works with your OpenWeather key
✅ Wrote and ran JavaScript scripts:

weather_one_city.js → fetch 1 city’s weather
weather_variations.js → loop through multiple cities
weather_flags.js → pass cities from the CLI, control units with a flag (and .env default)

✅ Pushed everything to GitHub under API-Lab org

I will admit, I am lost with the node.js language. I really struggled understanding what was going here. 


# Learning Journal — Week 3 (Node.js)

---

## Day 16 (W3D2)
I extended my CLI tool with new outputs. Added `--json` to console, `--json-out` to write JSON to a file, and `--csv-out` to export data to CSV. Enhanced the fetch to include wind speed, country, and ISO timestamps. Also added a `--json-only` flag to suppress human-readable lines.  
**Skills learned:** JSON/CSV outputs in Node, extending objects, optional chaining, formatting timestamps.  
**Deliverables:** `weather_cli.js` (final version with all flags).

/*
BIG PICTURE — weather_cli.js

1) Imports & setup
   - Load libs, rebuild __dirname, load .env next to this file

2) Config & flags
   - Read OPENWEATHER_API_KEY
   - Parse CLI: --units, --json, --csv-out; positional city names

3) Fetch function
   - Given a city, call OpenWeather, shape a normalized result { ok, city, temp, ... }

4) Run all requests
   - Promise.all(...) to fetch all cities in parallel

5) Output
   - Human-readable lines
   - Optional: JSON (--json)
   - Optional: CSV (--csv-out)
*/

## Day 17 (W3D3)
I added a simple daily cache so repeat runs don’t hit the API. I also extended outputs with wind speed and ISO timestamps. 

Tested `--json-only`, `--json-out`, and `--csv-out`. The CLI now feels fast and reusable.

# Week 3 – Day 18 (W3D4)

## What I Worked On
- Added **error hinting** to `fetchCity` so that API errors (401 Unauthorized, 404 Not Found, 429 Too Many Requests) return structured error messages instead of silent failures.
- Sketched out **tests** for each error case, so I know how to validate behavior when the API fails or limits requests.
- Confirmed CSV is in **append mode** and the run log tracks every execution.
- Cleaned up the code with the `--quiet` flag wrapping non-essential logs.

## What I Learned
- How to return structured objects in JS (`{ ok: false, error: ... }`) to make downstream logic easier to handle.
- Why appending CSV and logging runs is useful for history, debugging, and data tracking.
- How Git rebasing works when my local branch is behind the remote.
- Gained confidence working in Node.js even though it’s new territory.

## Next Steps
- Start adding **unit tests** with Jest for error cases.
- Refactor the CLI into smaller modules (`fetch.js`, `cache.js`, `output.js`).
- Keep updating the README with testing instructions and usage examples.



Learning Journal — Week 3, Day 5 (W3D5 / Day 19)
What I Did
- Added error hinting support to the weather CLI with a new src/hintForError.js module.
- Wrote unit tests with Jest to validate both fetchCity (API success/failure cases) and hintForError (status → human hint mapping).
- Debugged Jest configuration for ESM mode:
- Set "type": "module" in package.json.
- Updated the test script to use node --experimental-vm-modules.
- Ensured tests import Jest globals from @jest/globals.
- Fixed import/export mismatches (export async function fetchCity vs missing default exports).
- Created a run log inside logs/weather_runs.csv and ensured the CSV output file is in append mode.
- Cleaned up repo: committed changes with git pull --rebase flow to resolve remote conflicts.

What I Learned
- Testing in Node.js is different than in Python:
- Jest requires explicit setup for ESM (--experimental-vm-modules).
- Imports must match exports exactly — no auto-magic like Python.
- Tests need at least one it(...) block, otherwise Jest errors out.
- I now understand the purpose of tests:
- They simulate success/failure so I don’t have to wait for API errors in real runs. This makes the CLI more resilient.
- Learned how to add a helper module (hintForError) for better UX — turning raw API errors into human-readable hints.
- Reinforced Git best practices:
- Always pull with --rebase before pushing if remote has new commits.
- Fix conflicts locally, then push again.

Next Steps (W3D6+)
- Add more test coverage:
- Test CSV append logic.
- Test caching behavior (--cache-day).
- Try running tests in CI (GitHub Actions).

Begin planning next week’s project: moving toward FastAPI + service structure.


### Learning Journal — Weather CLI Chart Migration

**What I did**
- Replaced `chartjs-node-canvas` (native bindings) with `quickchart-js`, which works cleanly with Node.js v22 and avoids painful canvas install issues.
- Added two major features:
  1. `--chart-type` → supports both bar (snapshot) and line (historical trend).
  2. `--chart-from-csv` → allows chart generation from existing CSV logs without new API calls.
- Fixed CSV parsing logic so that boolean values (`true` vs `"true"`) don’t break.
- Implemented city-based grouping for line charts.

**Why I did it**
- Native canvas libraries were breaking under Node v22 (string conversion errors).
- Needed a stable charting backend that doesn’t rely on system-level builds.
- Wanted to visualize weather trends over time, not just current snapshots.

**Impact**
- Charts are now much more reliable and portable.
- Added flexibility: can visualize past data without hitting the API.
- Simplified dev setup: no native module headaches, faster install.

**Outcome**
- CLI is now production-friendly: daily CSV logging, reliable charts, cache, and summaries.
- More extensible foundation: I can later add rolling averages, anomaly detection, or export charts to the web.
- Learned the value of swapping libraries when friction is too high—QuickChart solved problems instantly compared to fighting `canvas`.
